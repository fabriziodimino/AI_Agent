import json
import logging
import numpy as np
from pathlib import Path
from typing import List, Tuple, Optional
from FlagEmbedding import BGEM3FlagModel
from sklearn.metrics.pairwise import cosine_similarity

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

class EmailEmbedder:
    """Standalone system for managing email embeddings."""
    
    def __init__(self, model_name: str = 'BAAI/bge-m3'):
        self.model = self._load_model(model_name)
        self.embedding_matrix: Optional[np.ndarray] = None
        self.metadata: List[dict] = []
        
        # Path configuration
        self.data_dir = Path("data")
        self.embeddings_dir = Path("embeddings")
        self.embeddings_path = self.embeddings_dir / "email_embeddings.npy"
        self.metadata_path = self.embeddings_dir / "email_metadata.json"

    def _load_model(self, model_name: str) -> BGEM3FlagModel:
        """Load the embedding model."""
        try:
            logger.info(f"Loading model {model_name}...")
            return BGEM3FlagModel(model_name, use_fp16=True)
        except Exception as e:
            logger.error(f"Error loading model: {str(e)}")
            raise

    def load_emails(self) -> List[dict]:
        """Load all emails generated by the main system."""
        emails = []
        try:
            for email_file in self.data_dir.glob("email_*.json"):
                with open(email_file, "r", encoding="utf-8") as f:
                    emails.append(json.load(f))
            logger.info(f"Found {len(emails)} emails in the database")
            return emails
        except Exception as e:
            logger.error(f"Error loading emails: {str(e)}")
            raise

    def generate_embeddings(self, emails: List[dict]) -> None:
        """Generate and save embeddings for all emails."""
        if not emails:
            raise ValueError("No emails to process")
            
        try:
            # Extract combined text (subject + body)
            texts = [f"{email['subject']}\n{email['body']}" for email in emails]
            
            # Generate embeddings
            logger.info("Generating embeddings...")
            embeddings = self.model.encode(texts)['dense_vecs']
            
            # Save embeddings and metadata
            self._save_embeddings(embeddings)
            self._save_metadata(emails)
            logger.info(f"Saved {len(embeddings)} embeddings successfully")

        except Exception as e:
            logger.error(f"Error generating embeddings: {str(e)}")
            raise

    def _save_embeddings(self, embeddings: np.ndarray) -> None:
        """Save the embedding matrix."""
        self.embeddings_dir.mkdir(exist_ok=True, parents=True)
        np.save(self.embeddings_path, embeddings)

    def _save_metadata(self, emails: List[dict]) -> None:
        """Save email metadata for reference."""
        self.metadata = [
            {
                "id": idx,
                "subject": email["subject"],
                "sender": email["from"],
                "body": email["body"],
                "file": f"email_{idx:03d}.json"
            } for idx, email in enumerate(emails)
        ]
        
        with open(self.metadata_path, "w", encoding="utf-8") as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)

    def load_embeddings(self) -> None:
        """Load existing embeddings and metadata."""
        try:
            self.embedding_matrix = np.load(self.embeddings_path)
            with open(self.metadata_path, "r", encoding="utf-8") as f:
                self.metadata = json.load(f)
            logger.info(f"Loaded {len(self.embedding_matrix)} embeddings")
        except FileNotFoundError:
            logger.error("Embeddings not found. Generate them first.")
            raise
        except Exception as e:
            logger.error(f"Error loading embeddings: {str(e)}")
            raise

    def search(self, query: str, top_k: int = 5) -> List[Tuple[int, float]]:
        """Perform a semantic search."""
        if self.embedding_matrix is None:
            self.load_embeddings()

        try:
            # Generate embedding for the query
            query_embedding = self.model.encode([query])['dense_vecs'][0]
            
            # Compute cosine similarity
            similarities = cosine_similarity([query_embedding], self.embedding_matrix)[0]
            
            # Sort results
            results = sorted(enumerate(similarities), key=lambda x: x[1], reverse=True)
            return results[:top_k]

        except Exception as e:
            logger.error(f"Error during search: {str(e)}")
            raise

    def get_email_details(self, email_id: int) -> dict:
        """Retrieve full details of an email."""
        try:
            return self.metadata[email_id]
        except IndexError:
            logger.error(f"Email ID {email_id} not found")
            raise
        except Exception as e:
            logger.error(f"Error retrieving details: {str(e)}")
            raise

if __name__ == "__main__":
    # Example usage
    embedder = EmailEmbedder()
    
    # 1. Load generated emails
    emails = embedder.load_emails()
    
    # 2. Generate and save embeddings (run only once)
    embedder.generate_embeddings(emails)
    
    # 3. Example search
    results = embedder.search("financial investments", top_k=2)
    
    # 4. Display results
    print("\nTop results:")
    for idx, score in results:
        details = embedder.get_email_details(idx)
        print(f"\nScore: {score:.4f}")
        print(f"Subject: {details['subject']}")
        print(f"Sender: {details['sender']}")
        print(f"File: {details['file']}")